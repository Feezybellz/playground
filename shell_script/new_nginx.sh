
#!/bin/bash
# Function to validate domain format
validate_domain() {
    # Add domain validation logic here
    # Return 0 if valid, 1 otherwise
    return 0
}

# Function to validate project folder format
validate_project_folder() {
    # Add project folder validation logic here
    # Return 0 if valid, 1 otherwise
    return 0
}

echo "Insert Domain:"
read -r domain

# Validate domain input
if ! validate_domain "$domain"; then
    echo "Invalid domain format. Please enter a valid domain."
    exit 1
fi

echo "Insert Project root (e.g., /vagrant/project-folder/www):"
read -r rootfolder

# Validate project folder input
if ! validate_project_folder "$rootfolder"; then
    echo "Invalid project folder format. Please enter a valid project folder."
    exit 1
fi


echo "Add SSL? (y/n)"
read -r ssl_response

if [[ $ssl_response == "y" || $ssl_response == "yes" ]]; then
    nginx_ssl_config="
        listen 443 ssl;
        ssl_certificate /etc/letsencrypt/live/$domain/fullchain.pem; # managed by Certbot
        ssl_certificate_key /etc/letsencrypt/live/$domain/privkey.pem; # managed by Certbot
        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
        "
    nginx_redirect_http_to_https="
        # Redirect HTTP to HTTPS
        server {
            listen 80;
            server_name $domain;
            return 301 https://$domain\$request_uri;
        }
    "
else
    nginx_ssl_config="listen 80;";
    nginx_redirect_http_to_https="";
fi

echo "Are you sure you want to set up $rootfolder to $domain? (y/n)"
read -r response

if [[ $response == "y" || $response == "yes" ]]; then
    if [ ! -d "$rootfolder" ]; then
        mkdir -p "$rootfolder"
    fi

    if [ ! -f "/etc/nginx/sites-available/$domain" ]; then
        # Update hosts file
        echo "127.0.0.1   $domain" >> /etc/hosts

        # Create Nginx server block
        nginx_config="/etc/nginx/sites-available/$domain"
        cat > "$nginx_config" <<EOL

# Nginx server block configuration for $domain
server {
    #listen 80;
    $nginx_ssl_config
    #listen [::]:80;

    # SSL configuration
    #
    # listen 443 ssl;
    # listen [::]:443 ssl;
    #
    # Note: You should disable gzip for SSL traffic.
    # See: https://bugs.debian.org/773332
    #
    # Read up on ssl_ciphers to ensure a secure configuration.
    # See: https://bugs.debian.org/765782
    #
    # Self signed certs generated by the ssl-cert package
    # Don't use them in a production server!
    #
    # include snippets/snakeoil.conf;

    root $rootfolder;

    # Add index.php to the list if you are using PHP
    index index.html index.htm index.nginx-debian.html index.php;

    server_name $domain;

    location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        #try_files \$uri \$uri/ =404;
        try_files \$uri \$uri/ /index.php?\$query_string;
    }

    # pass PHP scripts to FastCGI server
    #
    location ~ \.php\$ {
                fastcgi_split_path_info ^(.+\.php)(/.+)\$;
        include snippets/fastcgi-php.conf;
    #
    #   # With php-fpm (or other unix sockets):
    #   fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
    #   # With php-cgi (or other tcp sockets):
        fastcgi_pass 127.0.0.1:9000;
                include fastcgi_params;
    }

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #   deny all;
    #}
}

$nginx_redirect_http_to_https
EOL

        # Create symbolic link for enabled sites
        ln -s "$nginx_config" "/etc/nginx/sites-enabled/$domain"

        # Restart Nginx
        service nginx restart

        echo "Server Created Successfully, you can now visit http://$domain"
    else
        echo "A server block already exists for $domain. Check /etc/nginx/sites-available/ or edit /etc/nginx/sites-available/$domain"
    fi
else
    echo "Setup was terminated"
fi
